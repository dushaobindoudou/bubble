const fs = require('fs');
const path = require('path');

/**
 * Update Client Contract Addresses
 * This script updates the client-side contract addresses after deployment
 */

async function updateClientContracts() {
    console.log('ðŸ”„ æ›´æ–°å®¢æˆ·ç«¯åˆçº¦åœ°å€...\n');

    try {
        // Read the deployment artifacts
        const deploymentPath = path.join(__dirname, '../deployments/monad-testnet');
        const clientDeploymentPath = path.join(__dirname, '../src/client/contracts/deployment.json');

        // Check if deployment directory exists
        if (!fs.existsSync(deploymentPath)) {
            console.log('âš ï¸  éƒ¨ç½²ç›®å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹é…ç½®...');
            await createExampleConfig(clientDeploymentPath);
            return;
        }

        // Read contract addresses from deployment artifacts
        const contracts = {};
        const contractNames = [
            'RandomGenerator',
            'AccessControlManager', 
            'BubbleToken',
            'BubbleSkinNFT',
            'GameRewards',
            'Marketplace'
        ];

        let totalGasUsed = 0;
        const gasUsed = {};
        const verification = {};

        for (const contractName of contractNames) {
            const artifactPath = path.join(deploymentPath, `${contractName}.json`);
            
            if (fs.existsSync(artifactPath)) {
                const artifact = JSON.parse(fs.readFileSync(artifactPath, 'utf8'));
                contracts[contractName] = artifact.address;
                gasUsed[contractName] = artifact.receipt?.gasUsed || 0;
                totalGasUsed += gasUsed[contractName];
                
                verification[contractName] = {
                    verified: false,
                    explorerUrl: `https://testnet.monadexplorer.com/address/${artifact.address}`
                };
                
                console.log(`âœ… ${contractName}: ${artifact.address}`);
            } else {
                console.log(`âš ï¸  ${contractName}: æœªæ‰¾åˆ°éƒ¨ç½²ä¿¡æ¯`);
                contracts[contractName] = '0x0000000000000000000000000000000000000000';
                gasUsed[contractName] = 0;
                verification[contractName] = {
                    verified: false,
                    explorerUrl: ''
                };
            }
        }

        // Create deployment configuration
        const deploymentConfig = {
            network: 'monad-testnet',
            chainId: 10143,
            deployedAt: new Date().toISOString(),
            deployer: process.env.DEPLOYER_ADDRESS || '0x0000000000000000000000000000000000000000',
            contracts,
            verification,
            gasUsed: {
                ...gasUsed,
                total: totalGasUsed
            },
            notes: [
                'This file is automatically generated by the deployment script',
                'Contract addresses are updated after successful deployment to Monad Testnet',
                'Verification status can be updated manually after contract verification'
            ]
        };

        // Ensure client contracts directory exists
        const clientContractsDir = path.dirname(clientDeploymentPath);
        if (!fs.existsSync(clientContractsDir)) {
            fs.mkdirSync(clientContractsDir, { recursive: true });
        }

        // Write the deployment configuration
        fs.writeFileSync(
            clientDeploymentPath,
            JSON.stringify(deploymentConfig, null, 2)
        );

        console.log(`\nâœ… å®¢æˆ·ç«¯åˆçº¦é…ç½®å·²æ›´æ–°: ${clientDeploymentPath}`);
        console.log(`ðŸ“Š æ€» Gas ä½¿ç”¨é‡: ${totalGasUsed.toLocaleString()}`);

        // Update the web3-config.js file with contract addresses
        await updateWeb3Config(contracts);

        // Generate a JavaScript file for direct inclusion
        await generateContractJS(contracts);

        console.log('\nðŸŽ‰ å®¢æˆ·ç«¯åˆçº¦åœ°å€æ›´æ–°å®Œæˆï¼');

    } catch (error) {
        console.error('âŒ æ›´æ–°å®¢æˆ·ç«¯åˆçº¦åœ°å€å¤±è´¥:', error);
        process.exit(1);
    }
}

/**
 * Create example configuration when no deployment exists
 */
async function createExampleConfig(clientDeploymentPath) {
    const exampleConfig = {
        network: 'monad-testnet',
        chainId: 10143,
        deployedAt: new Date().toISOString(),
        deployer: '0x0000000000000000000000000000000000000000',
        contracts: {
            RandomGenerator: '0x0000000000000000000000000000000000000000',
            AccessControlManager: '0x0000000000000000000000000000000000000000',
            BubbleToken: '0x0000000000000000000000000000000000000000',
            BubbleSkinNFT: '0x0000000000000000000000000000000000000000',
            GameRewards: '0x0000000000000000000000000000000000000000',
            Marketplace: '0x0000000000000000000000000000000000000000'
        },
        verification: {},
        gasUsed: {},
        notes: [
            'This is an example configuration',
            'Run deployment script to populate with actual contract addresses'
        ]
    };

    // Ensure directory exists
    const clientContractsDir = path.dirname(clientDeploymentPath);
    if (!fs.existsSync(clientContractsDir)) {
        fs.mkdirSync(clientContractsDir, { recursive: true });
    }

    fs.writeFileSync(
        clientDeploymentPath,
        JSON.stringify(exampleConfig, null, 2)
    );

    console.log('âœ… åˆ›å»ºç¤ºä¾‹é…ç½®æ–‡ä»¶');
}

/**
 * Update web3-config.js with contract addresses
 */
async function updateWeb3Config(contracts) {
    const configPath = path.join(__dirname, '../src/client/js/web3-config.js');
    
    if (!fs.existsSync(configPath)) {
        console.log('âš ï¸  web3-config.js ä¸å­˜åœ¨ï¼Œè·³è¿‡æ›´æ–°');
        return;
    }

    let configContent = fs.readFileSync(configPath, 'utf8');
    
    // Update CONTRACT_ADDRESSES object
    const contractAddressesRegex = /const CONTRACT_ADDRESSES = \{[^}]*\}/s;
    const newContractAddresses = `const CONTRACT_ADDRESSES = {
    BubbleToken: '${contracts.BubbleToken}',
    BubbleSkinNFT: '${contracts.BubbleSkinNFT}',
    GameRewards: '${contracts.GameRewards}',
    Marketplace: '${contracts.Marketplace}',
    RandomGenerator: '${contracts.RandomGenerator}',
    AccessControlManager: '${contracts.AccessControlManager}'
}`;

    configContent = configContent.replace(contractAddressesRegex, newContractAddresses);
    
    fs.writeFileSync(configPath, configContent);
    console.log('âœ… æ›´æ–° web3-config.js');
}

/**
 * Generate a JavaScript file for direct inclusion in HTML
 */
async function generateContractJS(contracts) {
    const jsPath = path.join(__dirname, '../src/client/js/contracts.js');
    
    const jsContent = `/**
 * Bubble Brawl Contract Addresses
 * Auto-generated by deployment script
 * Generated at: ${new Date().toISOString()}
 */

// Contract addresses on Monad Testnet
window.BUBBLE_BRAWL_CONTRACTS = {
    BubbleToken: '${contracts.BubbleToken}',
    BubbleSkinNFT: '${contracts.BubbleSkinNFT}',
    GameRewards: '${contracts.GameRewards}',
    Marketplace: '${contracts.Marketplace}',
    RandomGenerator: '${contracts.RandomGenerator}',
    AccessControlManager: '${contracts.AccessControlManager}'
};

// Network information
window.BUBBLE_BRAWL_NETWORK = {
    chainId: 10143,
    name: 'Monad Testnet',
    rpcUrl: 'https://testnet-rpc.monad.xyz',
    explorerUrl: 'https://testnet.monadexplorer.com',
    currency: 'MON'
};

console.log('ðŸ«§ Bubble Brawl contracts loaded:', window.BUBBLE_BRAWL_CONTRACTS);
`;

    fs.writeFileSync(jsPath, jsContent);
    console.log('âœ… ç”Ÿæˆ contracts.js');
}

/**
 * Verify contracts on Monad Explorer (placeholder)
 */
async function verifyContracts(contracts) {
    console.log('\nðŸ” åˆçº¦éªŒè¯çŠ¶æ€:');
    
    for (const [name, address] of Object.entries(contracts)) {
        if (address !== '0x0000000000000000000000000000000000000000') {
            const explorerUrl = `https://testnet.monadexplorer.com/address/${address}`;
            console.log(`   ${name}: ${explorerUrl}`);
        }
    }
    
    console.log('\nðŸ’¡ æç¤º: è¯·æ‰‹åŠ¨åœ¨ Monad Explorer ä¸ŠéªŒè¯åˆçº¦');
}

// Run the script
if (require.main === module) {
    updateClientContracts()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error(error);
            process.exit(1);
        });
}

module.exports = {
    updateClientContracts,
    createExampleConfig,
    updateWeb3Config,
    generateContractJS
};
